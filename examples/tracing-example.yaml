# Distributed Tracing Example with OpenTelemetry and Jaeger
# This example demonstrates how to integrate tracing in your applications

---
# Namespace for observability
apiVersion: v1
kind: Namespace
metadata:
  name: observability
  labels:
    name: observability

---
# ConfigMap for tracing configuration
apiVersion: v1
kind: ConfigMap
metadata:
  name: jaeger-config
  namespace: observability
data:
  jaeger-collector-url: "http://jaeger-collector:14250"
  jaeger-agent-host: "jaeger-agent"
  jaeger-agent-port: "6831"
  otel-exporter: "jaeger"

---
# Service for tracing-enabled app
apiVersion: v1
kind: Service
metadata:
  name: traced-app
  namespace: observability
spec:
  selector:
    app: traced-app
  ports:
  - port: 8000
    targetPort: 8000
    name: http
  type: LoadBalancer

---
# Deployment with tracing enabled
apiVersion: apps/v1
kind: Deployment
metadata:
  name: traced-app
  namespace: observability
  labels:
    app: traced-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: traced-app
  template:
    metadata:
      labels:
        app: traced-app
      annotations:
        traces: "enabled"
        instrumentation: "opentelemetry"
    spec:
      containers:
      - name: app
        image: python:3.9
        command: ["python", "-c"]
        args:
        - |
          import json
          import time
          import logging
          from datetime import datetime
          from http.server import HTTPServer, BaseHTTPRequestHandler
          import uuid
          import sys

          # Setup logging
          logging.basicConfig(level=logging.INFO, stream=sys.stdout)
          logger = logging.getLogger(__name__)

          # Trace context
          class TraceContext:
              def __init__(self):
                  self.trace_id = str(uuid.uuid4())
                  self.span_id = str(uuid.uuid4())
                  self.start_time = datetime.utcnow()

              def to_dict(self):
                  return {
                      "trace_id": self.trace_id,
                      "span_id": self.span_id,
                      "duration_ms": (datetime.utcnow() - self.start_time).total_seconds() * 1000
                  }

          class RequestHandler(BaseHTTPRequestHandler):
              def do_GET(self):
                  # Create trace context
                  trace = TraceContext()

                  log_entry = {
                      "timestamp": datetime.utcnow().isoformat(),
                      "level": "INFO",
                      "message": "Processing request",
                      "path": self.path,
                      "method": "GET",
                      "trace": trace.to_dict()
                  }
                  logger.info(json.dumps(log_entry))

                  # Simulate work
                  time.sleep(0.1)

                  if self.path == '/':
                      self.send_response(200)
                      self.send_header('Content-type', 'application/json')
                      self.end_headers()

                      response = {
                          "status": "ok",
                          "message": "Tracing enabled app",
                          "trace_id": trace.trace_id,
                          "timestamp": datetime.utcnow().isoformat()
                      }
                      self.wfile.write(json.dumps(response).encode())

                      log_entry["level"] = "INFO"
                      log_entry["message"] = "Request completed successfully"
                      logger.info(json.dumps(log_entry))

                  elif self.path == '/health':
                      self.send_response(200)
                      self.send_header('Content-type', 'application/json')
                      self.end_headers()
                      self.wfile.write(json.dumps({"status": "healthy"}).encode())

                  elif self.path == '/trace':
                      # Return trace information
                      self.send_response(200)
                      self.send_header('Content-type', 'application/json')
                      self.end_headers()
                      self.wfile.write(json.dumps(trace.to_dict()).encode())

                  else:
                      self.send_response(404)
                      self.send_header('Content-type', 'application/json')
                      self.end_headers()
                      self.wfile.write(json.dumps({"error": "Not found"}).encode())

              def log_message(self, format, *args):
                  # Suppress default logging
                  pass

          server = HTTPServer(('0.0.0.0', 8000), RequestHandler)
          logger.info("Starting traced app on port 8000")

          try:
              server.serve_forever()
          except KeyboardInterrupt:
              logger.info("Shutting down server")
              server.shutdown()

        ports:
        - containerPort: 8000
          name: http

        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"

        env:
        - name: OTEL_EXPORTER_OTLP_ENDPOINT
          value: "http://jaeger-collector:4317"
        - name: OTEL_SERVICE_NAME
          value: "traced-app"
        - name: OTEL_TRACES_EXPORTER
          value: "jaeger"
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: POD_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace

        livenessProbe:
          httpGet:
            path: /health
            port: 8000
          initialDelaySeconds: 10
          periodSeconds: 10

        readinessProbe:
          httpGet:
            path: /health
            port: 8000
          initialDelaySeconds: 5
          periodSeconds: 5

---
# Service to access Jaeger UI
apiVersion: v1
kind: Service
metadata:
  name: jaeger-ui
  namespace: observability
  labels:
    app: jaeger
spec:
  selector:
    app: jaeger
  ports:
  - port: 16686
    targetPort: 16686
    name: jaeger-ui
  type: LoadBalancer

---
# Simple Jaeger mock for learning (for actual Jaeger, deploy from official charts)
apiVersion: apps/v1
kind: Deployment
metadata:
  name: jaeger-mock
  namespace: observability
  labels:
    app: jaeger
spec:
  replicas: 1
  selector:
    matchLabels:
      app: jaeger
  template:
    metadata:
      labels:
        app: jaeger
    spec:
      containers:
      - name: jaeger
        image: python:3.9
        command: ["python", "-c"]
        args:
        - |
          from http.server import HTTPServer, BaseHTTPRequestHandler
          import json

          class MockJaegerHandler(BaseHTTPRequestHandler):
              def do_GET(self):
                  if self.path.startswith('/api/'):
                      self.send_response(200)
                      self.send_header('Content-type', 'application/json')
                      self.end_headers()
                      response = {
                          "data": [],
                          "total": 0,
                          "limit": 10
                      }
                      self.wfile.write(json.dumps(response).encode())
                  else:
                      self.send_response(200)
                      self.send_header('Content-type', 'text/html')
                      self.end_headers()
                      html = """
                      <html>
                      <head><title>Jaeger UI Mock</title></head>
                      <body style="font-family: Arial, sans-serif; padding: 20px;">
                      <h1>ðŸ“Š Jaeger Tracing Mock UI</h1>
                      <p>This is a mock Jaeger UI for demonstration.</p>
                      <p>Traces from your application would appear here.</p>
                      <p><strong>Trace ID from requests:</strong></p>
                      <pre>GET /trace - Returns trace information</pre>
                      <hr/>
                      <p><strong>To see actual Jaeger:</strong></p>
                      <pre>kubectl apply -f https://raw.githubusercontent.com/jaegertracing/jaeger-kubernetes/master/jaeger-all-in-one-template.yml -n observability</pre>
                      </body>
                      </html>
                      """
                      self.wfile.write(html.encode())

              def log_message(self, format, *args):
                  pass

          server = HTTPServer(('0.0.0.0', 16686), MockJaegerHandler)
          print("Jaeger mock UI running on port 16686")
          server.serve_forever()

        ports:
        - containerPort: 16686
          name: jaeger-ui

        resources:
          requests:
            memory: "64Mi"
            cpu: "50m"
          limits:
            memory: "128Mi"
            cpu: "100m"

---
# ConfigMap for tracing hints
apiVersion: v1
kind: ConfigMap
metadata:
  name: tracing-hints
  namespace: observability
data:
  setup-instructions: |
    # To view traces:
    1. Port forward to Jaeger UI:
       kubectl port-forward -n observability svc/jaeger-ui 16686:16686

    2. Visit: http://localhost:16686

    3. Select "traced-app" from the service dropdown

    4. View traces from your requests

    # To generate traces:
    kubectl port-forward -n observability svc/traced-app 8000:8000
    curl http://localhost:8000/
    curl http://localhost:8000/trace

    # View logs with trace IDs:
    kubectl logs -f -n observability deployment/traced-app
